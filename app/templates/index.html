<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Library Manager</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <!-- Theme Toggle Button -->
    <div class="theme-toggle" id="theme-toggle">
        <i class="material-icons" id="theme-icon">dark_mode</i>
    </div>

    <div class="main-container">
        <div class="container">
            <!-- Header -->
            <div class="row">
                <div class="col s12 center-align">
                    <h1 class="white-text" style="font-weight: 700; margin-bottom: 0.5rem;">Music Library Manager</h1>
                    <p class="white-text" style="opacity: 0.9; font-size: 1.1rem;">Organize your music collection with ease</p>
                </div>
            </div>

            <!-- Settings Link -->
            <div class="row">
                <div class="col s12 center-align">
                    <a href="/settings" class="btn waves-effect waves-light" style="margin-bottom: 1rem;">
                        <i class="material-icons left">settings</i>
                        Settings
                    </a>
                    <button class="btn waves-effect waves-light" id="show-paths-btn" style="margin-bottom: 1rem; margin-left: 10px;">
                        <i class="material-icons left">folder</i>
                        Show Paths
                    </button>
                </div>
            </div>

            <!-- Flash Messages -->
            <div id="flash-messages" style="display: none;">
                {% with messages = get_flashed_messages(with_categories=true) %}
                    {% if messages %}
                        {% for category, message in messages %}
                            <div data-message="{{ message | e }}" data-category="{{ category }}"></div>
                        {% endfor %}
                    {% endif %}
                {% endwith %}
            </div>

            <!-- Main Form -->
            <div class="row">
                <div class="col s12 m8 offset-m2">
                    <div class="card">
                        <div class="card-content">
                            <span class="card-title">Download & Organize Music</span>
                            
                            <form id="playlist-form" method="POST">
                                <!-- URL Input -->
                                <div class="input-field">
                                    <i class="material-icons prefix">link</i>
                                    <input type="text" id="url" name="url">
                                    <label for="url">Playlist URL (optional - will use download folder if not provided)</label>
                                </div>
                                
                                <!-- Playlist Options -->
                                <div class="form-section">
                                    <h6>Playlist Options</h6>
                                    <div class="switch">
                                        <label>
                                            <input type="checkbox" id="add_to_existing_playlist" name="add_to_existing_playlist">
                                            <span class="lever"></span>
                                            Add to existing playlist
                                        </label>
                                    </div>
                                </div>
                                
                                <!-- New Playlist Name -->
                                <div id="new-playlist-section">
                                    <div class="input-field">
                                        <i class="material-icons prefix">music_note</i>
                                        <input type="text" id="playlist_name" name="playlist_name">
                                        <label for="playlist_name">New Playlist Name</label>
                                    </div>
                                </div>
                                
                                <!-- Existing Playlist Selection -->
                                <div id="existing-playlist-section" style="display: none;">
                                    <div class="input-field">
                                        <i class="material-icons prefix">playlist_play</i>
                                        <select id="existing_playlist_name" name="existing_playlist_name">
                                            <option value="" disabled selected>Choose existing playlist</option>
                                            {% for playlist in existing_playlists %}
                                            <option value="{{ playlist.name }}">{{ playlist.name }} ({{ playlist.song_count }} songs)</option>
                                            {% endfor %}
                                        </select>
                                        <label>Existing Playlist</label>
                                    </div>
                                </div>
                                
                                <!-- Download Options -->
                                {% if show_download_options %}
                                <div class="form-section">
                                    <h6>Download Options</h6>
                                    <div class="switch">
                                        <label>
                                            <input type="checkbox" id="use_download_folder" name="use_download_folder">
                                            <span class="lever"></span>
                                            Use songs in download folder (skip spotdl)
                                        </label>
                                    </div>
                                    <div class="switch">
                                        <label>
                                            <input type="checkbox" id="keep_download_files" name="keep_download_files">
                                            <span class="lever"></span>
                                            Keep files in download folder
                                        </label>
                                    </div>
                                </div>
                                {% endif %}
                                
                                <!-- Submit Button -->
                                <button type="submit" class="btn waves-effect waves-light" id="submit-btn">
                                    <span id="submit-text">Process & Create</span>
                                    <i class="material-icons right">send</i>
                                </button>
                            </form>
                            
                            <!-- Progress Section -->
                            <div id="progress" class="progress-container" style="display: none;">
                                <h6>Download Progress</h6>
                                <div class="progress-text" id="progress-text">Initializing...</div>
                                <div class="progress-bar">
                                    <div class="progress-fill" id="progress-fill"></div>
                                </div>
                                <div class="stats">
                                    <div class="stat-item">
                                        <span class="stat-number" id="songs-downloaded">0</span>
                                        <span class="stat-label">Songs</span>
                                    </div>
                                    <div class="stat-item">
                                        <span class="stat-number" id="progress-percentage">0%</span>
                                        <span class="stat-label">Progress</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Search Section -->
            <div class="row">
                <div class="col s12 m8 offset-m2">
                    <div class="search-section">
                        <h5 class="section-title">Search Library</h5>
                        <div class="input-field">
                            <i class="material-icons prefix">search</i>
                            <input type="text" id="search-input" placeholder="Search for a song by title, artist, or album...">
                            <label for="search-input">Search Library</label>
                        </div>
                        <button class="btn waves-effect waves-light" id="search-btn">
                            <i class="material-icons left">search</i>
                            Search
                        </button>
                        <div id="search-result" style="display: none;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            M.updateTextFields();
            M.FormSelect.init(document.querySelectorAll('select'));

            // Initialize playlists on page load
            initializePlaylists();

            // Check for flash messages and refresh playlists if needed
            checkForFlashMessages();

            // Show paths button functionality
            const showPathsBtn = document.querySelector('#show-paths-btn');
            showPathsBtn.addEventListener('click', showCurrentPaths);

            // Theme management
            const themeToggle = document.querySelector('#theme-toggle');
            const themeIcon = document.querySelector('#theme-icon');
            const body = document.body;
            
            // Load saved theme
            const savedTheme = localStorage.getItem('theme') || 'light';
            body.setAttribute('data-theme', savedTheme);
            updateThemeIcon(savedTheme);
            
            // Theme toggle functionality
            themeToggle.addEventListener('click', function() {
                const currentTheme = body.getAttribute('data-theme') || 'light';
                const newTheme = currentTheme === 'light' ? 'dark' : 'light';
                
                body.setAttribute('data-theme', newTheme);
                localStorage.setItem('theme', newTheme);
                updateThemeIcon(newTheme);
                
                // Reinitialize Materialize components for new theme
                M.updateTextFields();
                M.FormSelect.init(document.querySelectorAll('select'));
            });
            
            function updateThemeIcon(theme) {
                if (theme === 'dark') {
                    themeIcon.textContent = 'light_mode';
                } else {
                    themeIcon.textContent = 'dark_mode';
                }
            }

            // Flash messages
            const flashMessages = document.querySelectorAll('#flash-messages > div');
            flashMessages.forEach(msg => {
                const message = msg.dataset.message;
                const category = msg.dataset.category;
                M.toast({
                    html: message,
                    classes: category === 'success' ? 'green' : 'red',
                    displayLength: 4000
                });
            });

            // Search functionality
            const searchInput = document.querySelector('#search-input');
            const searchBtn = document.querySelector('#search-btn');
            const searchResult = document.querySelector('#search-result');

            searchBtn.addEventListener('click', async function() {
                const query = searchInput.value.trim();
                if (!query) {
                    M.toast({html: 'Please enter a search term', classes: 'orange'});
                    return;
                }

                searchBtn.innerHTML = '<span class="loading"></span> Searching...';
                searchBtn.disabled = true;

                try {
                    const results = await performSearch(query);
                    displaySearchResults(results);
                } catch (error) {
                    console.error('Search failed:', error);
                    M.toast({html: 'Search failed', classes: 'red'});
                } finally {
                    searchBtn.innerHTML = '<i class="material-icons left">search</i>Search';
                    searchBtn.disabled = false;
                }
            });

            // Add search on Enter key
            searchInput.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    searchBtn.click();
                }
            });

            function performSearch(query) {
                // Make actual API call to backend
                return fetch(`/api/search?q=${encodeURIComponent(query)}`)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                        }
                        return response.json();
                    })
                    .then(data => {
                        if (data.error) {
                            throw new Error(data.error);
                        }
                        return data.results;
                    })
                    .catch(error => {
                        console.error('Search error:', error);
                        M.toast({html: 'Search failed: ' + error.message, classes: 'red'});
                        return [];
                    });
            }

            function displaySearchResults(results) {
                searchResult.style.display = 'block';
                
                if (results.length === 0) {
                    searchResult.innerHTML = `
                        <div class="search-result not-found">
                            <h6>No songs found</h6>
                            <p>No songs matching your search were found in the library.</p>
                        </div>
                    `;
                } else {
                    let html = '';
                    results.forEach(song => {
                        html += `
                            <div class="search-result">
                                <h6>${song.title}</h6>
                                <p><strong>Artist:</strong> ${song.artist}</p>
                                <p><strong>Album:</strong> ${song.album}</p>
                                <p><strong>Location:</strong> ${song.path}</p>
                            </div>
                        `;
                    });
                    searchResult.innerHTML = html;
                }
            }

            // Playlist option handling
            const addToExistingCheckbox = document.querySelector('#add_to_existing_playlist');
            const newPlaylistSection = document.querySelector('#new-playlist-section');
            const existingPlaylistSection = document.querySelector('#existing-playlist-section');
            const submitText = document.querySelector('#submit-text');
            const playlistNameInput = document.querySelector('#playlist_name');
            const existingPlaylistSelect = document.querySelector('#existing_playlist_name');

            // Function to refresh playlists
            async function refreshPlaylists() {
                try {
                    const response = await fetch('/api/playlists/refresh', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    if (data.success) {
                        // Update the existing playlist select options
                        updatePlaylistOptions(data.playlists);
                        M.toast({html: 'Playlists refreshed successfully', classes: 'green'});
                    } else {
                        throw new Error(data.error || 'Failed to refresh playlists');
                    }
                } catch (error) {
                    console.error('Failed to refresh playlists:', error);
                    M.toast({html: 'Failed to refresh playlists: ' + error.message, classes: 'red'});
                }
            }

            // Function to initialize playlists on page load
            async function initializePlaylists() {
                try {
                    const response = await fetch('/api/playlists');
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const playlists = await response.json();
                    if (Array.isArray(playlists)) {
                        updatePlaylistOptions(playlists);
                    } else {
                        console.warn('Unexpected playlist data format:', playlists);
                    }
                } catch (error) {
                    console.error('Failed to initialize playlists:', error);
                    // Don't show error toast on page load, just log it
                }
            }

            // Function to check for flash messages and refresh playlists if needed
            function checkForFlashMessages() {
                const flashMessages = document.querySelectorAll('#flash-messages > div');
                if (flashMessages.length > 0) {
                    // If there are flash messages, it means an operation was completed
                    // Refresh playlists after a short delay to show updated data
                    setTimeout(() => {
                        refreshPlaylists();
                    }, 1000);
                }
            }

            // Function to show current paths
            async function showCurrentPaths() {
                try {
                    const response = await fetch('/api/paths');
                    
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const paths = await response.json();
                    displayPathsModal(paths);
                } catch (error) {
                    console.error('Failed to get paths:', error);
                    M.toast({html: 'Failed to get paths: ' + error.message, classes: 'red'});
                }
            }

            // Function to display paths in modal
            function displayPathsModal(paths) {
                let modalContent = `
                    <div class="modal-content">
                        <h4>Current Folder Configuration</h4>
                        <div class="paths-info">
                            <p><strong>Root Folder:</strong> ${paths.root_folder}</p>
                            <p><strong>Download Directory:</strong> ${paths.download_dir}</p>
                            <p><strong>Playlist Directory:</strong> ${paths.playlist_dir}</p>
                            <p><strong>Music Library Directory:</strong> ${paths.music_lib_dir}</p>
                        </div>
                        <div class="resolved-paths">
                            <h5>Resolved Paths:</h5>
                            <p><strong>Download:</strong> ${paths.resolved.download_dir}</p>
                            <p><strong>Playlists:</strong> ${paths.resolved.playlist_dir}</p>
                            <p><strong>Music Library:</strong> ${paths.resolved.music_lib_dir}</p>
                        </div>
                        <div class="paths-help">
                            <h5>How to change paths:</h5>
                            <p>1. Go to <strong>Settings</strong> page</p>
                            <p>2. Change the <strong>Root Folder</strong> to your desired location</p>
                            <p>3. The other paths will automatically update relative to the root folder</p>
                            <p>4. Or set absolute paths if you prefer</p>
                        </div>
                    </div>
                `;
                
                // Create and show modal
                const modal = document.createElement('div');
                modal.className = 'modal';
                modal.innerHTML = modalContent;
                document.body.appendChild(modal);
                
                const instance = M.Modal.init(modal);
                instance.open();
                
                // Clean up modal when closed
                modal.addEventListener('click', function(e) {
                    if (e.target === modal) {
                        instance.close();
                        setTimeout(() => {
                            document.body.removeChild(modal);
                        }, 300);
                    }
                });
            }

            // Function to update playlist options
            function updatePlaylistOptions(playlists) {
                const select = document.querySelector('#existing_playlist_name');
                const currentValue = select.value;
                
                // Clear existing options
                select.innerHTML = '<option value="" disabled selected>Choose existing playlist</option>';
                
                // Add new options
                playlists.forEach(playlist => {
                    const option = document.createElement('option');
                    option.value = playlist.name;
                    option.textContent = `${playlist.name} (${playlist.song_count} songs)`;
                    select.appendChild(option);
                });
                
                // Restore previous selection if it still exists
                if (currentValue) {
                    const option = select.querySelector(`option[value="${currentValue}"]`);
                    if (option) {
                        option.selected = true;
                    }
                }
                
                // Reinitialize Materialize select
                M.FormSelect.init(select);
            }

            addToExistingCheckbox.addEventListener('change', function() {
                if (this.checked) {
                    newPlaylistSection.style.display = 'none';
                    existingPlaylistSection.style.display = 'block';
                    submitText.textContent = 'Process & Add to Playlist';
                    playlistNameInput.removeAttribute('required');
                    existingPlaylistSelect.setAttribute('required', 'required');
                    
                    // Automatically refresh playlists when opening the dropdown
                    refreshPlaylists();
                } else {
                    newPlaylistSection.style.display = 'block';
                    existingPlaylistSection.style.display = 'none';
                    submitText.textContent = 'Process & Create';
                    playlistNameInput.setAttribute('required', 'required');
                    existingPlaylistSelect.removeAttribute('required');
                }
                M.updateTextFields();
                M.FormSelect.init(document.querySelectorAll('select'));
            });

            // Update submit button text based on URL input
            urlInput.addEventListener('input', function() {
                if (!this.value.trim()) {
                    submitText.textContent = 'Process & Create from Download Folder';
                } else {
                    submitText.textContent = 'Process & Create';
                }
            });

            // Add click event to the select to refresh playlists when opened
            existingPlaylistSelect.addEventListener('click', function() {
                // Refresh playlists when the dropdown is clicked
                refreshPlaylists();
            });

            // Function to handle successful form submission
            function handleSuccessfulSubmission() {
                // Reset form
                form.reset();
                
                // Reset UI state
                isDownloading = false;
                submitBtn.classList.remove('disabled');
                progressContainer.style.display = 'none';
                
                // Refresh playlists after a short delay
                setTimeout(() => {
                    refreshPlaylists();
                }, 1000);
                
                // Show success message
                M.toast({html: 'Operation completed successfully!', classes: 'green'});
            }

            // Form handling
            const form = document.querySelector('#playlist-form');
            const submitBtn = document.querySelector('#submit-btn');
            const progressContainer = document.querySelector('#progress');
            const progressText = document.querySelector('#progress-text');
            const progressFill = document.querySelector('#progress-fill');
            const songsDownloaded = document.querySelector('#songs-downloaded');
            const progressPercentage = document.querySelector('#progress-percentage');
            const useDownloadFolder = document.querySelector('#use_download_folder');
            const urlInput = document.querySelector('#url');
            let source = null;
            let isDownloading = false;
            let downloadCount = 0;
            let totalSongs = 0;

            // Handle form submission without download progress
            form.addEventListener('submit', function(event) {
                // If using download folder, let the form submit normally
                if (useDownloadFolder.checked) {
                    // The form will submit and redirect, so we don't need to prevent default
                    // But we can add a loading state
                    submitBtn.innerHTML = '<span class="loading"></span> Processing...';
                    submitBtn.disabled = true;
                    
                    // After a delay, refresh playlists (since the page will reload)
                    setTimeout(() => {
                        if (typeof refreshPlaylists === 'function') {
                            refreshPlaylists();
                        }
                    }, 3000);
                    return;
                }
                
                // For URL-based downloads, prevent default and handle with EventSource
                event.preventDefault();
                if (isDownloading) {
                    M.toast({html: 'A download is already in progress.', classes: 'red'});
                    return;
                }

                const url = urlInput.value;
                const addToExisting = addToExistingCheckbox.checked;
                
                // If no URL is provided, automatically use download folder
                if (!url) {
                    useDownloadFolder.checked = true;
                    urlInput.disabled = true;
                    
                    // Submit the form normally for download folder processing
                    submitBtn.innerHTML = '<span class="loading"></span> Processing...';
                    submitBtn.disabled = true;
                    
                    // After a delay, refresh playlists (since the page will reload)
                    setTimeout(() => {
                        if (typeof refreshPlaylists === 'function') {
                            refreshPlaylists();
                        }
                    }, 3000);
                    return;
                }

                if (!addToExisting && !playlistNameInput.value.trim()) {
                    M.toast({html: 'Please provide a playlist name.', classes: 'orange'});
                    return;
                }

                if (addToExisting && !existingPlaylistSelect.value) {
                    M.toast({html: 'Please select an existing playlist.', classes: 'orange'});
                    return;
                }

                isDownloading = true;
                submitBtn.classList.add('disabled');
                downloadCount = 0;
                totalSongs = 0;

                if (!useDownloadFolder.checked) {
                    progressContainer.style.display = 'block';
                    progressText.textContent = 'Starting download...';
                    progressFill.style.width = '0%';
                    songsDownloaded.textContent = '0';
                    progressPercentage.textContent = '0%';
                }

                if (source) {
                    source.close();
                }

                source = new EventSource(`/download-progress?url=${encodeURIComponent(url)}`);
                source.onmessage = function(event) {
                    const data = event.data;
                    console.log('Progress data:', data);
                    
                    // Parse progress information
                    if (data.includes('Downloading') || data.includes('downloading')) {
                        downloadCount++;
                        if (totalSongs === 0) {
                            // Estimate total songs from first download
                            totalSongs = Math.max(downloadCount + 5, 10);
                        }
                        
                        const percentage = Math.min((downloadCount / totalSongs) * 100, 100);
                        progressFill.style.width = percentage + '%';
                        songsDownloaded.textContent = downloadCount;
                        progressPercentage.textContent = Math.round(percentage) + '%';
                        progressText.textContent = `Downloading song ${downloadCount}...`;
                    } else if (data.includes('Downloaded') || data.includes('downloaded')) {
                        progressText.textContent = data;
                    } else if (data.includes('Found') || data.includes('found')) {
                        const match = data.match(/(\d+) songs/);
                        if (match) {
                            totalSongs = parseInt(match[1]);
                        }
                    } else if (data.includes('Skipping') || data.includes('skipping')) {
                        // Count skipped songs too
                        downloadCount++;
                        if (totalSongs === 0) {
                            totalSongs = Math.max(downloadCount + 5, 10);
                        }
                        
                        const percentage = Math.min((downloadCount / totalSongs) * 100, 100);
                        progressFill.style.width = percentage + '%';
                        songsDownloaded.textContent = downloadCount;
                        progressPercentage.textContent = Math.round(percentage) + '%';
                        progressText.textContent = `Processing song ${downloadCount}...`;
                    } else if (data.includes('Processing') || data.includes('processing')) {
                        downloadCount++;
                        if (totalSongs === 0) {
                            totalSongs = Math.max(downloadCount + 5, 10);
                        }
                        
                        const percentage = Math.min((downloadCount / totalSongs) * 100, 100);
                        progressFill.style.width = percentage + '%';
                        songsDownloaded.textContent = downloadCount;
                        progressPercentage.textContent = Math.round(percentage) + '%';
                        progressText.textContent = `Processing song ${downloadCount}...`;
                    } else if (data.includes('Completed') || data.includes('completed') || data.includes('Success')) {
                        // Operation completed successfully
                        progressText.textContent = 'Operation completed successfully!';
                        setTimeout(() => {
                            handleSuccessfulSubmission();
                        }, 1000);
                    }
                };
                
                source.onerror = function() {
                    progressText.textContent = 'Download completed or connection lost.';
                    source.close();
                    isDownloading = false;
                    submitBtn.classList.remove('disabled');
                    
                    // Submit the form and then refresh playlists
                    form.submit();
                    // Refresh playlists after a short delay to allow backend processing
                    setTimeout(() => {
                        refreshPlaylists();
                    }, 2000);
                };
                
                source.onopen = function() {
                    progressText.textContent = 'Connected to download progress stream.';
                };
            });

            // Disable URL input if using download folder
            useDownloadFolder.addEventListener('change', function() {
                urlInput.disabled = this.checked;
                if (this.checked) {
                    urlInput.value = '';
                }
            });
        });
    </script>
</body>
</html>